"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.A2AErrorSchema = exports.ArtifactSchema = exports.MessagePartSchema = exports.TaskStateSchema = void 0;
const zod_1 = require("zod");
/**
 * @module A2AProtocol
 * @description Core types and schemas for the Agent-to-Agent (A2A) protocol
 *
 * This module defines the core types and schemas used throughout the A2A protocol,
 * including tasks, messages, artifacts, and agent metadata. These types form the
 * foundation of all communication between agents and clients in the protocol.
 *
 * The module uses Zod schemas for runtime validation of data structures, ensuring
 * that all communication adheres to the protocol specification. Type definitions
 * are derived from these schemas for TypeScript type safety.
 */
/**
 * Schema defining the possible states of a task in the A2A protocol
 * @remarks This is used for validation with Zod
 */
exports.TaskStateSchema = zod_1.z.enum([
    'submitted', // Task has been submitted but processing hasn't started
    'working', // Task is currently being processed
    'input_required', // Task requires additional input to continue
    'completed', // Task has been successfully completed
    'failed', // Task has failed to complete
    'canceled' // Task was canceled before completion
]);
/**
 * Schema defining the different types of message parts in the A2A protocol
 * @remarks Uses a discriminated union based on the 'type' field
 */
exports.MessagePartSchema = zod_1.z.discriminatedUnion('type', [
    /**
     * Text message part for plain text or markdown content
     */
    zod_1.z.object({
        type: zod_1.z.literal('text'),
        content: zod_1.z.string(),
        format: zod_1.z.enum(['plain', 'markdown']).default('plain')
    }),
    /**
     * File message part for binary or base64-encoded file content
     */
    zod_1.z.object({
        type: zod_1.z.literal('file'),
        content: zod_1.z.union([zod_1.z.string(), zod_1.z.instanceof(Uint8Array)]),
        mimeType: zod_1.z.string(),
        name: zod_1.z.string(),
        size: zod_1.z.number().optional()
    }),
    /**
     * Data message part for structured data objects
     */
    zod_1.z.object({
        type: zod_1.z.literal('data'),
        content: zod_1.z.record(zod_1.z.any()),
        schema: zod_1.z.string().optional()
    }),
    /**
     * Heartbeat message part for connection maintenance
     */
    zod_1.z.object({
        type: zod_1.z.literal('heartbeat'),
        content: zod_1.z.string(),
        format: zod_1.z.literal('plain').default('plain')
    })
]);
/**
 * Schema defining artifacts produced during task execution
 * @remarks Artifacts are persistent outputs from tasks that can be referenced later
 */
exports.ArtifactSchema = zod_1.z.object({
    /** Unique identifier for the artifact */
    id: zod_1.z.string(),
    /** The type of content this artifact contains */
    type: zod_1.z.enum(['text', 'file', 'data']),
    /** The actual content of the artifact */
    content: zod_1.z.record(zod_1.z.any()),
    /** ISO timestamp when the artifact was created */
    createdAt: zod_1.z.string(),
    /** ISO timestamp when the artifact was last updated */
    updatedAt: zod_1.z.string()
});
/**
 * Schema defining standardized errors in the A2A protocol
 * @remarks Error codes follow JSON-RPC error code conventions
 */
exports.A2AErrorSchema = zod_1.z.object({
    /** Error code in the JSON-RPC reserved range */
    code: zod_1.z.number().min(-32099).max(-32000),
    /** Human-readable error message */
    message: zod_1.z.string(),
    /** Optional additional error data */
    data: zod_1.z.record(zod_1.z.any()).optional()
});
//# sourceMappingURL=a2a-protocol.js.map