"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventConsumer = void 0;
class EventConsumer {
    constructor(taskId, queueManager, handler) {
        this.taskId = taskId;
        this.queueManager = queueManager;
        this.handler = handler;
        this.isRunning = false;
        this.processingTimes = [];
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isRunning) {
                return;
            }
            this.isRunning = true;
            const tappedQueue = yield this.queueManager.tap(this.taskId);
            this.queue = tappedQueue;
            this.stats = yield this.queueManager.getStats(this.taskId);
            while (this.isRunning) {
                try {
                    const startTime = Date.now();
                    const event = yield tappedQueue.dequeue();
                    if (event === undefined) { // Check for queue end
                        break;
                    }
                    yield this.handler(event);
                    const processingTime = Date.now() - startTime;
                    this.processingTimes.push(processingTime);
                    this.updateStats({
                        processed: this.stats.processed + 1,
                        throughput: this.calculateThroughput(),
                        avgProcessingTime: this.calculateAvgProcessingTime()
                    });
                }
                catch (error) {
                    this.updateStats({
                        failed: this.stats.failed + 1,
                        errorRate: this.stats.failed / (this.stats.processed + this.stats.failed)
                    });
                    throw error;
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isRunning = false;
            yield this.queue.close();
        });
    }
    updateStats(updates) {
        Object.assign(this.stats, updates);
        this.queueManager.updateStats(this.taskId, this.stats);
    }
    calculateThroughput() {
        // Calculate events per second over last 10 events
        const windowSize = Math.min(10, this.processingTimes.length);
        if (windowSize === 0)
            return 0;
        const window = this.processingTimes.slice(-windowSize);
        const totalTime = window.reduce((sum, time) => sum + time, 0);
        return windowSize / (totalTime / 1000);
    }
    calculateAvgProcessingTime() {
        if (this.processingTimes.length === 0)
            return 0;
        return this.processingTimes.reduce((sum, time) => sum + time, 0) /
            this.processingTimes.length;
    }
}
exports.EventConsumer = EventConsumer;
//# sourceMappingURL=event-consumer.js.map