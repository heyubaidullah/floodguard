/**
 * @module Telemetry
 * @description Decorators for instrumenting code with OpenTelemetry
 */
import { type Context } from '@opentelemetry/api';
/**
 * Configuration options for the Trace decorator
 */
type TraceOptions = {
    /** Custom name for the span (defaults to ClassName.methodName) */
    name?: string;
    /** Parent context for the span (for manual context propagation) */
    parentContext?: Context;
};
/**
 * Method decorator that automatically creates a span for the decorated method
 *
 * This decorator instruments methods with OpenTelemetry tracing, creating spans
 * that track method execution, timing, and errors. It supports both synchronous
 * and asynchronous methods.
 *
 * @param nameOrOptions - Optional span name or configuration object
 *
 * @example
 * ```typescript
 * class UserService {
 *   // Basic usage
 *   @Trace()
 *   async getUser(id: string) {
 *     // Method implementation
 *   }
 *
 *   // With custom span name
 *   @Trace('FetchUserDetails')
 *   async getUserDetails(id: string) {
 *     // Method implementation
 *   }
 *
 *   // With options object
 *   @Trace({ name: 'UserAuthentication' })
 *   async authenticateUser(username: string, password: string) {
 *     // Method implementation
 *   }
 * }
 * ```
 */
export declare function Trace(nameOrOptions?: string | TraceOptions): any;
/**
 * Method decorator for recording metrics when a method is called
 *
 * This decorator records metrics each time the decorated method is called,
 * allowing for monitoring method usage, performance, and other custom metrics.
 *
 * @param name - The name of the metric to record
 * @param value - Optional value to record (default: 1)
 * @param attributes - Optional attributes to include with the metric
 * @returns A method decorator
 *
 * @example
 * ```typescript
 * class MessageService {
 *   // Count message sends
 *   @Metric('messages.sent')
 *   async sendMessage(message: Message) {
 *     // Implementation
 *   }
 *
 *   // Record message size with custom value
 *   @Metric('message.size', message.content.length)
 *   async processMessage(message: Message) {
 *     // Implementation
 *   }
 *
 *   // Include additional attributes
 *   @Metric('api.call', 1, { endpoint: '/messages' })
 *   async fetchMessages() {
 *     // Implementation
 *   }
 * }
 * ```
 */
export declare function Metric(name: string, value?: number, attributes?: Record<string, unknown>): any;
/**
 * Class decorator to automatically trace all methods in a class
 *
 * This decorator applies the Trace decorator to all methods in a class,
 * making it easy to instrument an entire class without decorating each
 * method individually.
 *
 * @param name - Optional custom name prefix for the spans (defaults to class name)
 * @returns A class decorator
 *
 * @example
 * ```typescript
 * // Basic usage - traces all methods with ClassName.methodName
 * @TraceClass()
 * class UserService {
 *   async getUser(id: string) {
 *     // Method implementation
 *   }
 *   async updateUser(id: string, data: any) {
 *     // Method implementation
 *   }
 * }
 *
 * // With custom name prefix
 * @TraceClass('Users')
 * class UserService {
 *   // Will be traced as 'Users.getUser'
 *   async getUser(id: string) {
 *     // Method implementation
 *   }
 * }
 * ```
 */
export declare function TraceClass(name?: string): ClassDecorator;
export {};
//# sourceMappingURL=decorators.d.ts.map