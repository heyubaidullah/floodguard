"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdkChatTransport = void 0;
const ai_1 = require("ai");
const utils_1 = require("../utils");
/**
 * A transport class for handling chat messages in the ADK client.
 * This class extends HttpChatTransport to provide methods for sending messages
 * and processing response streams.
 */
class AdkChatTransport extends ai_1.HttpChatTransport {
    constructor(adk) {
        super({});
        this.adk = adk;
    }
    processResponseStream(stream) {
        const messageId = (0, utils_1.generateUUID)();
        const transformStream = new TransformStream({
            transform(chunk, controller) {
                var _a, _b;
                const decoder = new TextDecoder();
                const text = decoder.decode(chunk);
                const lines = text.split("\n");
                for (const line of lines) {
                    if (line.startsWith("data: ")) {
                        try {
                            const json = JSON.parse(line.substring(6));
                            if ((json === null || json === void 0 ? void 0 : json.partial) && ((_b = (_a = json === null || json === void 0 ? void 0 : json.content) === null || _a === void 0 ? void 0 : _a.parts) === null || _b === void 0 ? void 0 : _b[0].text)) {
                                const chunk = {
                                    type: "text-delta",
                                    id: messageId,
                                    delta: json.content.parts[0].text,
                                };
                                controller.enqueue(chunk);
                            }
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                }
            },
        });
        return stream.pipeThrough(transformStream);
    }
    sendMessages(_a) {
        return __awaiter(this, arguments, void 0, function* ({ messages, chatId, sessionId, }) {
            const resolvedSessionId = sessionId !== null && sessionId !== void 0 ? sessionId : chatId;
            if (!resolvedSessionId) {
                throw new Error("Session ID or Chat ID is required");
            }
            const response = yield this.adk.runSse(resolvedSessionId, messages);
            if (!response.body) {
                throw new Error("No response body from ADK agent");
            }
            return this.processResponseStream(response.body);
        });
    }
}
exports.AdkChatTransport = AdkChatTransport;
//# sourceMappingURL=client.js.map